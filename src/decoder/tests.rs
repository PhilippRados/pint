#[cfg(test)]
mod tests {
    use crate::decoder::*;
    use std::io::Write;
    use std::process::Command;
    use tempfile::NamedTempFile;
    // TRUECOLOR-RGB IMAGE TESTS

    #[test]
    fn can_parse_chunks() {
        // ihdr block
        let buf = vec![
            0b0,
            0b0,
            0b0,
            0b0000_1101,
            0b0100_1001,
            0b0100_1000,
            0b0100_0100,
            0b0101_0010,
            0b0,
            0b0,
            0b0,
            0b10010110,
            0b0,
            0b0,
            0b0,
            0b10010001,
            0b0000_1000,
            0b0000_0010,
            0b0,
            0b0,
            0b0,
            0b10101110,
            0b01100110,
            0b11010110,
            0b00001101,
        ];

        let result = parse_png_chunks(&buf);
        assert_eq!(result.as_ref().unwrap().chunk_len, 25);
        assert_eq!(result.as_ref().unwrap().data_len, 13);
        assert_eq!(result.as_ref().unwrap().chunk_type, "IHDR");
        assert_eq!(
            result.as_ref().unwrap().data,
            [
                0b0,
                0b0,
                0b0,
                0b10010110,
                0b0,
                0b0,
                0b0,
                0b10010001,
                0b0000_1000,
                0b0000_0010,
                0b0,
                0b0,
                0b0,
            ]
        );
    }
    #[test]
    fn can_parse_ihdr_data() {
        // ihdr block
        let buf = vec![
            0b0,
            0b0,
            0b0,
            0b10010110,
            0b0,
            0b0,
            0b0,
            0b10010001,
            0b0000_1000,
            0b0000_0010,
            0b0,
            0b0,
            0b0,
        ];

        let result = parse_ihdr(buf);
        assert_eq!(result.width, 150);
        assert_eq!(result.height, 145);
        assert_eq!(result.bit_depth, 8);
        assert_eq!(result.color_type, ColorType::TrueColorRGB);
    }
    #[test]
    fn can_convert_multibyte_arr_to_int() {
        let buf = vec![0b0, 0b0, 0b0000_0010, 0b1001_1011];
        let result = bytes_to_int(&buf[..]);
        assert_eq!(result, 667);
    }
    #[test]
    fn can_convert_single_byte_arr_to_int() {
        let buf = vec![0b0, 0b0, 0b0, 0b1001_1011];
        let result = bytes_to_int(&buf[..]);
        assert_eq!(result, 155);
    }
    #[test]
    fn can_parse_truecolor_rgb_idat_to_rgb() {
        let idat = vec![vec![
            120, 218, 237, 221, 81, 110, 234, 48, 16, 64, 209, 166, 98, 95, 241, 210, 237, 149,
            185, 253, 181, 43, 25, 220, 152, 140, 175, 184, 231, 15, 245, 169, 228, 113, 53, 234,
            40, 16, 114, 212, 47, 128, 210, 62, 60, 191, 110, 58, 234, 210, 62, 115, 250, 125, 230,
            253, 124, 71, 31, 128, 174, 50, 33, 158, 9, 241, 76, 136, 247, 136, 122, 226, 163, 78,
            172, 36, 245, 136, 58, 76, 0, 167, 16, 207, 132, 120, 38, 196, 51, 33, 94, 216, 58, 51,
            230, 254, 242, 58, 167, 16, 207, 132, 120, 38, 196, 51, 33, 222, 113, 219, 155, 77,
            227, 211, 49, 123, 238, 47, 91, 30, 84, 207, 41, 196, 51, 33, 158, 9, 241, 76, 136,
            103, 66, 60, 19, 226, 153, 16, 207, 132, 120, 38, 196, 123, 235, 217, 25, 196, 199,
            140, 71, 60, 59, 163, 59, 152, 16, 207, 132, 120, 38, 196, 187, 244, 217, 153, 238,
            175, 125, 157, 253, 185, 86, 112, 10, 241, 76, 136, 103, 66, 60, 19, 226, 205, 173, 51,
            227, 253, 196, 237, 38, 132, 83, 136, 103, 66, 60, 19, 226, 153, 16, 239, 201, 58, 51,
            181, 129, 76, 110, 55, 90, 195, 41, 196, 51, 33, 158, 9, 241, 76, 136, 55, 247, 217,
            153, 110, 67, 201, 185, 121, 152, 82, 243, 112, 114, 127, 217, 113, 221, 241, 179, 51,
            186, 131, 9, 241, 76, 136, 103, 66, 188, 169, 111, 179, 123, 250, 203, 22, 30, 86, 192,
            107, 241, 244, 127, 148, 243, 22, 135, 213, 173, 141, 78, 33, 158, 9, 241, 76, 136,
            103, 66, 188, 149, 235, 12, 226, 92, 198, 74, 119, 45, 59, 41, 149, 193, 79, 157, 66,
            60, 19, 226, 153, 16, 207, 132, 120, 151, 214, 153, 79, 219, 95, 114, 137, 57, 59, 147,
            134, 175, 180, 83, 136, 103, 66, 60, 19, 226, 153, 16, 111, 242, 202, 166, 63, 247,
            130, 212, 13, 114, 234, 30, 55, 91, 149, 83, 136, 103, 66, 60, 19, 226, 153, 16, 111,
            110, 157, 169, 235, 246, 151, 195, 11, 159, 94, 214, 221, 65, 188, 219, 41, 157, 66,
            60, 19, 226, 153, 16, 207, 132, 120, 75, 63, 10, 60, 163, 180, 111, 220, 164, 238, 143,
            244, 153, 162, 94, 145, 129, 168, 55, 155, 198, 156, 66, 60, 19, 226, 153, 16, 207,
            132, 120, 143, 227, 200, 65, 79, 221, 238, 47, 53, 69, 191, 20, 84, 78, 33, 158, 9,
            241, 76, 136, 103, 66, 188, 75, 55, 57, 248, 52, 41, 53, 239, 144, 109, 114, 221, 182,
            83, 136, 103, 66, 60, 19, 226, 153, 16, 111, 155, 117, 102, 120, 149, 84, 237, 190,
            176, 239, 182, 131, 106, 191, 226, 165, 59, 140, 50, 243, 171, 222, 199, 41, 196, 51,
            33, 158, 9, 241, 76, 136, 183, 203, 58, 211, 159, 231, 8, 218, 95, 250, 163, 218, 227,
            48, 198, 156, 66, 60, 19, 226, 153, 16, 207, 132, 120, 38, 196, 51, 33, 158, 9, 241,
            76, 136, 103, 66, 60, 19, 226, 153, 16, 207, 132, 120, 38, 196, 51, 33, 222, 46, 111,
            54, 17, 157, 231, 255, 191, 22, 185, 172, 187, 230, 219, 41, 196, 51, 33, 158, 9, 241,
            76, 136, 231, 58, 19, 163, 187, 141, 228, 21, 78, 33, 158, 9, 241, 76, 136, 103, 66,
            60, 215, 153, 32, 117, 217, 13, 175, 156, 66, 60, 19, 226, 153, 16, 207, 132, 120, 174,
            51, 11, 229, 215, 255, 233, 194, 111, 172, 113, 10, 241, 76, 136, 103, 66, 60, 19, 226,
            133, 173, 51, 53, 183, 247, 127, 74, 209, 175, 4, 150, 83, 136, 103, 66, 60, 19, 226,
            153, 16, 207, 132, 120, 38, 196, 51, 33, 158, 9, 241, 76, 136, 103, 66, 60, 19, 226,
            153, 16, 207, 132, 120, 38, 196, 251, 1, 201, 164, 87, 175,
        ]];
        let mut meta = IHDRData::default();
        meta.width = 150;
        meta.color_type = ColorType::TrueColorRGB;
        let result = parse_data(idat, meta, None, RGBorU8::RGB(RGB(0, 0, 0)));

        // println!("{:?}",result);

        // result is too big so its stored in temp-file
        let mut tmp_file = NamedTempFile::new().expect("");
        writeln!(tmp_file, "{:?}", result);

        // correct file output is compared to test-file
        let output = Command::new("diff")
            .arg("./tests/snapshots/correct_rgb_idat")
            .arg(tmp_file.path())
            .output()
            .expect("failed to run diff-process");

        assert_eq!(output.stdout, []);
        assert_eq!(output.stderr, []);
    }

    // INDEXED IMAGE TESTS

    #[test]
    fn can_parse_indexed_idat_to_rgb_1() {
        let idat = vec![vec![
            104, 222, 237, 217, 57, 14, 194, 64, 16, 68, 81, 179, 122, 48, 139, 89, 238, 127, 87,
            194, 170, 160, 164, 22, 168, 33, 250, 63, 66, 200, 244, 115, 212, 26, 236, 105, 250,
            174, 253, 7, 237, 212, 4, 7, 7, 7, 215, 203, 157, 212, 80, 173, 220, 65, 193, 193, 193,
            193, 53, 115, 249, 138, 242, 38, 242, 207, 70, 12, 14, 14, 14, 238, 47, 92, 222, 142,
            153, 203, 131, 55, 106, 85, 179, 130, 131, 131, 131, 251, 29, 151, 7, 219, 197, 54,
            237, 166, 108, 130, 93, 176, 40, 91, 192, 112, 112, 112, 112, 205, 220, 89, 205, 177,
            173, 178, 19, 220, 85, 217, 19, 182, 151, 90, 98, 112, 112, 112, 112, 205, 156, 109,
            60, 51, 242, 185, 46, 255, 167, 205, 223, 90, 23, 5, 7, 7, 7, 215, 204, 217, 215, 153,
            179, 105, 199, 170, 44, 219, 90, 134, 131, 131, 131, 107, 230, 236, 243, 168, 178, 105,
            118, 6, 44, 119, 166, 29, 29, 225, 224, 224, 224, 154, 57, 59, 149, 229, 237, 88, 190,
            224, 44, 239, 210, 95, 134, 194, 193, 193, 193, 245, 114, 119, 101, 143, 213, 140, 179,
            141, 103, 39, 67, 27, 241, 84, 246, 30, 193, 30, 204, 61, 20, 28, 28, 28, 92, 47, 247,
            6, 249, 170, 78, 59,
        ]];

        let plte = Some(vec![
            RGB(255, 255, 192),
            RGB(0, 255, 255),
            RGB(192, 255, 192),
            RGB(192, 192, 0),
            RGB(255, 255, 0),
            RGB(0, 255, 0),
            RGB(255, 0, 0),
            RGB(0, 192, 0),
            RGB(255, 255, 255),
            RGB(0, 0, 0),
            RGB(192, 192, 255),
            RGB(0, 0, 192),
            RGB(0, 0, 255),
            RGB(192, 0, 0),
            RGB(255, 0, 255),
            RGB(192, 255, 255),
            RGB(255, 192, 192),
            RGB(0, 192, 192),
            RGB(255, 192, 255),
            RGB(192, 0, 192),
        ]);
        let mut meta = IHDRData::default();
        meta.width = 110;
        meta.color_type = ColorType::Indexed;
        let result = parse_data(idat, meta, plte, RGBorU8::U8(0));

        // result is too big so its stored in temp-file
        let mut tmp_file = NamedTempFile::new().expect("");
        writeln!(tmp_file, "{:?}", result);

        // correct file output is compared to test-file
        let output = Command::new("diff")
            .arg("./tests/snapshots/correct_index_idat")
            .arg(tmp_file.path())
            .output()
            .expect("failed to run diff-process");

        assert_eq!(output.stdout, []);
        assert_eq!(output.stderr, []);
    }
    #[test]
    fn can_parse_indexed_idat_to_rgb_2() {
        // artsy_hello_world
        let idat = vec![vec![
            104, 222, 237, 219, 193, 82, 194, 48, 16, 128, 225, 191, 165, 181, 80, 58, 8, 248, 254,
            175, 232, 168, 195, 84, 16, 68, 47, 184, 153, 173, 73, 155, 50, 158, 214, 205, 9, 146,
            38, 95, 14, 59, 201, 54, 129, 162, 66, 149, 47, 128, 43, 192, 3, 192, 69, 127, 10, 173,
            21, 64, 13, 240, 1, 176, 210, 173, 53, 192, 17, 160, 144, 214, 43, 192, 9, 160, 112,
            211, 150, 201, 116, 233, 152, 81, 14, 163, 173, 181, 155, 6, 205, 16, 183, 151, 148,
            116, 78, 117, 14, 165, 7, 104, 167, 117, 55, 45, 154, 79, 0, 175, 218, 236, 82, 210,
            160, 115, 159, 106, 109, 83, 240, 198, 77, 131, 230, 2, 224, 51, 51, 90, 51, 184, 96,
            158, 229, 225, 0, 239, 220, 52, 104, 238, 1, 158, 51, 67, 54, 131, 27, 135, 247, 110,
            26, 52, 91, 25, 38, 99, 195, 204, 229, 146, 102, 227, 166, 65, 243, 81, 175, 125, 189,
            126, 122, 144, 111, 221, 105, 34, 111, 12, 149, 155, 6, 205, 10, 96, 169, 7, 108, 117,
            4, 207, 15, 89, 82, 51, 239, 221, 52, 104, 182, 0, 165, 44, 78, 165, 28, 31, 117, 145,
            52, 60, 212, 117, 122, 30, 87, 233, 139, 174, 11, 165, 1, 88, 184, 105, 208, 44, 37,
            196, 6, 230, 64, 15, 1, 120, 146, 17, 106, 253, 202, 23, 51, 59, 189, 117, 174, 221,
            52, 104, 118, 114, 148, 112, 212, 93, 74, 29, 123, 77, 196, 68, 39, 88, 49, 115, 48,
            243, 210, 77, 131, 230, 78, 130, 114, 126, 220, 162, 235, 146, 235, 97, 24, 165, 118,
            211, 160, 185, 145, 202, 164, 57, 216, 3, 79, 211, 117, 177, 190, 97, 230, 110, 26, 51,
            99, 121, 252, 248, 113, 247, 157, 39, 86, 173, 155, 86, 205, 149, 164, 215, 100, 194,
            227, 87, 118, 253, 244, 124, 221, 52, 102, 110, 1, 94, 34, 219, 95, 174, 153, 123, 221,
            114, 0, 216, 186, 105, 208, 12, 247, 43, 221, 116, 240, 38, 143, 153, 50, 150, 204, 3,
            252, 190, 163, 115, 211, 130, 185, 2, 120, 215, 153, 210, 248, 34, 118, 190, 143, 3,
            126, 238, 232, 220, 52, 109, 142, 195, 237, 156, 125, 150, 136, 185, 113, 243, 159,
            152, 3, 56, 3, 25, 151, 66, 41, 220, 52, 104, 134, 28, 44, 89, 254, 240, 247, 183, 110,
            90, 52, 215, 178, 37, 94, 228, 173, 240, 34, 231, 74, 37, 220, 46, 248, 27, 249, 250,
            6, 183, 255, 6, 44, 165, 239, 66, 162, 255, 67, 119, 43, 225, 246, 7, 129, 240, 176,
            155, 182, 204, 111, 180, 198, 133, 101,
        ]];

        let plte = Some(vec![
            RGB(0, 0, 0),
            RGB(0, 0, 192),
            RGB(0, 0, 255),
            RGB(192, 0, 0),
            RGB(255, 0, 0),
            RGB(192, 0, 192),
            RGB(255, 0, 255),
            RGB(0, 192, 0),
            RGB(0, 192, 192),
            RGB(192, 192, 0),
            RGB(0, 255, 0),
            RGB(192, 192, 255),
            RGB(0, 255, 255),
            RGB(255, 192, 192),
            RGB(255, 192, 255),
            RGB(255, 255, 0),
            RGB(192, 255, 192),
            RGB(192, 255, 255),
            RGB(255, 255, 192),
            RGB(255, 255, 255),
        ]);
        let mut meta = IHDRData::default();
        meta.width = 115;
        meta.color_type = ColorType::Indexed;
        let result = parse_data(idat, meta, plte, RGBorU8::U8(0));

        // result is too big so its stored in temp-file
        let mut tmp_file = NamedTempFile::new().expect("");
        writeln!(tmp_file, "{:?}", result);

        // correct file output is compared to test-file
        let output = Command::new("diff")
            .arg("./tests/snapshots/correct_index_idat_artsy")
            .arg(tmp_file.path())
            .output()
            .expect("failed to run diff-process");

        assert_eq!(output.stdout, []);
        assert_eq!(output.stderr, []);
    }
}
